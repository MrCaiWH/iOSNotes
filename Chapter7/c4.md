## 常用方法

#### 常见方法1

    - (void)addPort:(NSPort *)aPort forMode:(NSRunLoopMode)mode;

该方法的作用就是：将端口作为输入源添加到运行循环的指定模式。其实就是往RunLoop的 Mode 中添加一个source1任务。

下面看一下参数：

* aPort：要加入的端口。
* mode：运行循环模式，还是那几种，前面已经说过了，这里就不多说了。

#### 常见方法2

    - (void)run;

该方法的作用就是：将接收器置于永久循环中，在此期间处理来自所有附加输入源的数据。**其实就是开启Runloop**。

NSRunLoop的run方法是无法停止的，它专门用于开启一个永不销毁的线程（NSRunLoop）。

run方法的底层实现其实是调用`- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;`方法。

这里还有几点需要注意：

* 主线程的Runloop是默认开启的，子线程需要调用该方法开启这个线程。
* 如果没有输入源或定时器连接到运行循环，则此方法立即退出; 否则，它通过重复调用`runMode：beforeDate：`来在`NSDefaultRunLoopMode`中运行接收器。 换句话说，这种方法有效地开始一个无限循环，用于处理来自运行循环的输入源和定时器的数据。
* 从运行循环手动删除所有已知的输入源和定时器不能保证运行循环将退出。 macOS可以根据需要安装和删除其他输入源，以处理针对接收者线程的请求。 因此，这些源可能会阻止运行循环退出。
* 如果你想要运行循环终止，你不应该使用这个方法。 相反，使用其他运行方法之一，还可以在循环中检查自己的其他任意条件。 ：、

#### 常见方法3

    - (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;

该方法的作用就是：**运行循环一次**，阻塞在指定模式下的输入，直到给定的日期到达。

* `return`：如果运行循环运行并处理输入源或者达到指定的超时值，则为“YES” 否则，如果运行循环无法启动，则为NO。

还有几点需要注意：

* 如果没有输入源或定时器连接到运行循环，此方法立即退出并返回NO; 否则，在第一个输入源被处理或达到limitDate之后返回。 从运行循环中手动删除所有已知的输入源和定时器并不能保证运行循环将立即退出。 macOS可以根据需要安装和删除其他输入源，以处理针对接收者线程的请求。 因此，这些源可能会阻止运行循环退出。
* 定时器不被认为是输入源，并且可能在等待该方法返回时多次触发。

这里我们说一下使用情况，在单线程的app中，不需要注意Run Loop，但不代表没有。程序启动时，系统已经在主线程中加入了Run Loop。它保证了我们的主线程在运行起来后，就处于一种“等待”的状态（而不像一些命令行程序一样运行一次就结束了），这个时候如果有接收到的事件（Timer的定时到了或是其他线程的消息），就会执行任务，否则就处于休眠状态。如果我们要写多线程的程序，可能就需要自己来管理Run Loop。

#### 常见方法4

    - (void)runUntilDate:(NSDate *)limitDate;

该方法的作用就是：运行循环直到指定的日期，在此期间，它处理所有附加的输入源的数据。
还有几个问题需要注意：

* 如果没有输入源或定时器连接到运行循环，则此方法立即退出；否则，它通过重复调用runMode：beforeDate:在NSDefaultRunLoopMode中运行接收器，直到指定的到期日期。
* 从运行循环手动删除所有已知的输入源和定时器不能保证运行循环将退出。 macOS可以根据需要安装和删除其他输入源，以处理针对接收者线程的请求。 因此，这些源可能会阻止运行循环退出。
* 同run方法，增加超时参数limitDate，避免进入无限循环。使用在UI线程（亦即主线程）上，可以达到暂停的效果。
* 使用run loop的一个好处就是避免线程轮询的开销，run loop在无事件处理时可以自动进入睡眠状态，降低CPU的能耗。
