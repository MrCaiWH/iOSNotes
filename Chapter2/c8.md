## 属性（property）

#### 属性实际是什么

>属性 = 成员变量 + set方法 + get方法。

在`编译阶段`，编译器会自动给对象添加一个实例变量和它的get、set方法。这个过程由于是在编译阶段自动合成的，所以我们在编辑阶段是看不到的。添加实例变量是有一个前提的，就是对象还`没有同名的成员变量`，就是如果已经有_str了，就`不再添加`了。

如果我们定义了set和get其中的`一个`，编译器还是会为我们生成另一个。例如，我们自定义get方法，编译器就会为我们生成set方法。如果我们同时自定义了属性的存取方法，编译器就不会为对象声明实例变量了。


###3 @synthesize

在MRC下，@synthesize str这样，编译器才会自动合成str的存取方法

#### @dynamic

关键字主要是告诉编译器属性的 setter 与 getter 方法由用户自己实现，不自动生成。即使我们没有实现，编译器也不会警告，因为它相信在运行阶段会实现。

如果用户没有自动生成，运行时调用缺失的方法会造成崩溃。

译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。

#### atomic

由编译器合成的set方法通过同步锁的机制保证其原子性（get方法没有加锁）。atomic修饰的属性的存取方法是线程安全的，nonatomic修饰的属性不具有原子性，不使用`自旋锁`。自己定义属性的存取方法的时候，也应该遵守与属性特质相符的原子性。

    // atomic原子性的实现
    - (void)setStr:(NSString *)str{
        @synchronized(self) {
            _str = str;
        }
    }

由于atomic具有一定的`性能开销`，所以我们应该把所有的属性都用nonatomic修饰。而且原子性也`不能保证线程安全`，因为如果`绕过set方法给属性赋值`，就是线程不安全的了。